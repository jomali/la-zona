

!!==============================================================================
!!
!!	LA ZONA
!!	Definición de atributos y clases
!!
!!==============================================================================
!!
!!	Archivo:		laZona_classes.inf
!!	Autor(es):		J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Idioma:			ES (Castellano)
!!	Sistema:		Inform-INFSP 6
!!	Plataforma:		GLULX
!!	Versión:		0.0
!!	Fecha:			2017/12/16
!!
!!------------------------------------------------------------------------------
!!
!!	# HISTORIAL DE VERSIONES
!!
!!	0.0: 2016/06/18	Inicio del desarrollo.
!!
!!------------------------------------------------------------------------------
!!
!!	Este archivo forma parte del relato interactivo LA ZONA.
!!
!!	LA ZONA es software libre: usted puede redistribuirlo y/o
!!	modificarlo bajo los términos de la Licencia Pública General GNU
!!	publicada por la Fundación para el Software Libre, ya sea la versión
!!	3 de la Licencia, o (a su elección) cualquier versión posterior.
!!
!!	LA ZONA se distribuye con la esperanza de que sea útil, pero
!!	SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita MERCANTIL o
!!	de APTITUD PARA UN PROPÓSITO DETERMINADO. Consulte los detalles de
!!	la Licencia Pública General GNU para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública General GNU
!!	junto a LA ZONA. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (c) 2018, J. Francisco Martín
!!
!!------------------------------------------------------------------------------
!!
!!	# TABLA DE CONTENIDOS
!!
!!	-	Atributo remarkable
!!	-	Direcciones Adelante/Atrás
!!	-	Clase Thing
!!		+	Clase Room
!!			*	Clase Outdoors
!!			*	Clase Indoors
!!		+	Clase Item
!!		+	Clase Furniture
!!		+	Clase Atrezzo
!!		+	Clase NPC
!!	-	Clase SmartEnterable
!!
!!------------------------------------------------------------------------------
!!
!!	# NOTA SOBRE LAS PROPIEDADES DE CLASE
!!
!!	Hay rutinas como 'before' o 'react_before' que son propiedades no aditivas,
!!	es decir, si se crea una clase que defina un comportamiento específico para
!!	una de estas propiedades, y a continuación se crea un objeto como instancia
!!	de esta clase de forma que también él defina su propia versión de alguna de
!!	estas propiedades no aditivas, las rutinas del objeto "sobreescribirán"
!!	completamente aquellas de la clase. Dicho de otra manera, si el objeto
!!	define las suyas propias, las rutinas 'before' y *react_before* de la clase
!!	de la que es instancia NO SERÁN INVOCADAS en ningún momento. Sin embargo,
!!	se puede hacer una llamada explícita a la rutina de la clase desde la
!!	rutina del objeto. A continuación se especifica cómo un objeto 'objectName'
!!	invocaría a la rutina 'react_before' de clase *className* de la que es
!!	instancia:
!!
!!		objectName.className::react_before();
!!
!!------------------------------------------------------------------------------


!!==============================================================================
!!	Atributo remarkable
!!------------------------------------------------------------------------------
!!	Marca un objeto como destacado. El usuario puede utilizar la acción
!!	##RemarkableObjects para obtener un listado de objetos destacados que se
!!	encuentren a su alcance. Los objetos destacados, además, se imprimen con
!!	un estilo de resaltado propio.
!!------------------------------------------------------------------------------

Attribute remarkable;


!!==============================================================================
!!	Direcciones Adelante/Atrás
!!------------------------------------------------------------------------------
!!	Se añaden dos direcciones nuevas: adelante y atrás, a las 12 direcciones
!!	por defecto de la librería: norte, sur, este, oeste, nordeste, noroeste,
!!	sudeste, sudoeste, arriba, abajo, interior y exterior (definidas en
!!	'Spanish.h').
!!------------------------------------------------------------------------------

Property b_to;
CompassDirection b_obj "atrás" compass
with name 'atras', door_dir b_to, has proper;

Property f_to;
CompassDirection f_obj "adelante" compass
 with	name 'adelante', door_dir f_to, has proper;


!!==============================================================================
!!	Clase Thing
!!------------------------------------------------------------------------------
!!	Representa un objeto dentro del modelo del mundo, con un tamaño, volumen y
!!	peso específicos, así como diferentes valores de capacidad asociados a su
!!	potencial como contenedor para otros objetos. Está ideada como una clase
!!	abstracta sobre la que definir el resto de subclases más concretas de
!!	objetos con los que modelar el mundo del relato.
!!------------------------------------------------------------------------------

Class	Thing
 with	size	0,			! Tamaño
		volume	0,			! Volumen
		weight	0,			! Peso
		capacity_number	-1,	! Capacidad total: en cuanto a número de objetos
		capacity_size	-1,	! Capacidad total: en cuanto a tamaño
		capacity_volume	-1,	! Capacidad total: en cuanto a volumen
		capacity_weight	-1,	! Capacidad total: en cuanto a peso
		action_set 0,
		description [;
			switch (_grammatical_inflection) {
				FIRST_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No vemos";
					else print "No veo";
				SECOND_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No veis";
					else print "No ves";
				THIRD_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No ven";
					else print "No ve";
				FIRST_PERSON_PAST:
					if (IsPluralNoun(player)) print "No vimos";
					else print "No vi";
				SECOND_PERSON_PAST:
					if (IsPluralNoun(player)) print "No visteis";
					else print "No viste";
				THIRD_PERSON_PAST:
					if (IsPluralNoun(player)) print "No vieron";
					else print "No vio";
				FIRST_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No veremos";
					else print "No veré";
				SECOND_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No veréis";
					else print "No verás";
				THIRD_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No verán";
					else print "No verá";
			}
			" nada especial en ", (the) self, ".";
		],
;


!!==============================================================================
!!	Clase Room
!!------------------------------------------------------------------------------
!!	Representa un objeto localidad dentro del modelo de mundo.
!!------------------------------------------------------------------------------

Class	Room
 with	description [;
			if (action == ##Look || self hasnt visited) self.long_description();
			else self.short_description();
			!! Espacio para elementos comunes a las dos descripciones.
			return true;
		],
		long_description "EN CONSTRUCCIÓN.",
		!! Por defecto, la descripción corta es la misma descripción larga:
		short_description [; return self.long_description(); ],
		!! Permite que se inhiba el listado automático de objetos al imprimir
		!! la descripción de la localidad. (XXX Para ello se debe modificar el
		!! comportamiento de la acción ##Look en el archivo de mensajes de la
		!! librería):
		inhibit_object_list false,
 has	light remarkable;


!!==============================================================================
!!	Clase Outdoors
!!------------------------------------------------------------------------------

Class	Outdoors
 class	Room;


!!==============================================================================
!!	Clase Indoors
!!------------------------------------------------------------------------------

Class	Indoors
 class	Room;


!!==============================================================================
!!	Clase Item
!!------------------------------------------------------------------------------
!!	Representa un objeto simple dentro del modelo de mundo sobre el que
!!	inicialmente no se aplican restricciones de ningún tipo.
!!------------------------------------------------------------------------------

Class	Item
 class	Thing
 with	description [;
			switch (_grammatical_inflection) {
				FIRST_PERSON_PRESENT,
				SECOND_PERSON_PRESENT,
				THIRD_PERSON_PRESENT:
					print "Tiene", (n) self;
				FIRST_PERSON_PAST,
				SECOND_PERSON_PAST,
				THIRD_PERSON_PAST:
					print "Tenía", (n) self;
				FIRST_PERSON_FUTURE,
				SECOND_PERSON_FUTURE,
				THIRD_PERSON_FUTURE:
					print "Tendrá", (n) self;
			}
			print " el mismo aspecto que ";
			if (IsPluralNoun(self)) print "cualesquiera";
			else print "cualquier";
			print " otr", (o) self, " ", (name) self, " que ";
			switch (_grammatical_inflection) {
				FIRST_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "hayamos";
					else print "haya";
				SECOND_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "hayáis";
					else print "hayas";
				THIRD_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "hayan";
					else print "haya";
				FIRST_PERSON_PAST:
					if (IsPluralNoun(player)) print "hubiésemos";
					else print "hubiese";
				SECOND_PERSON_PAST:
					if (IsPluralNoun(player)) print "hubieseis";
					else print "hubieses";
				THIRD_PERSON_PAST:
					if (IsPluralNoun(player)) print "hubiesen";
					else print "hubiese";
				FIRST_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "habremos";
					else print "habré";
				SECOND_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "habréis";
					else print "habrás";
				THIRD_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "habrán";
					else print "habrá";
			}
			" visto antes.";
		];


!!==============================================================================
!!	Clase Furniture.
!!------------------------------------------------------------------------------
!!	Representa un objeto estático dentro del modelo de mundo. Se aplica la
!!	restricción 'static' definida por la librería Inform.
!!------------------------------------------------------------------------------

Class	Furniture
 class	Thing,
 with	before [;
			Pull, Push, PushDir, Take, Turn:
				switch (_grammatical_inflection) {
					FIRST_PERSON_PRESENT,
					SECOND_PERSON_PRESENT,
					THIRD_PERSON_PRESENT:
						print (The) self, " ", (es) self;
					FIRST_PERSON_PAST,
					SECOND_PERSON_PAST,
					THIRD_PERSON_PAST:
						print (The) self, " era", (n) self;
					FIRST_PERSON_FUTURE,
					SECOND_PERSON_FUTURE,
					THIRD_PERSON_FUTURE:
						print (The) self, " será", (n) self;
				} " demasiado pesad", (o) self, " para andar moviéndol",
				(o) self, ".";
		],
 has	static;


!!==============================================================================
!!	Clase Atrezzo.
!!------------------------------------------------------------------------------
!!	Representa un objeto decorado dentro del modelo de mundo. Se aplica la
!!	restricción *scenery* definida por la librería Inform.
!!------------------------------------------------------------------------------

Class	Atrezzo
 class	Thing
 with	before [;
			DefaultAction, Examine, Search:
				return false;
			default:
				switch (_grammatical_inflection) {
					FIRST_PERSON_PRESENT:
						if (IsPluralNoun(player))
							print "No creemos que necesitemos preocuparnos";
						else print "No creo que necesite preocuparme";
					SECOND_PERSON_PRESENT:
						print "No es necesario que ";
						if (IsPluralNoun(player)) print "os preocupéis";
						else print "te preocupes";
					THIRD_PERSON_PRESENT:
						print "No es necesario que ";
						if (IsPluralNoun(player)) print "se preocupen";
						else print "se preocupe";
					FIRST_PERSON_PAST:
						if (IsPluralNoun(player))
							print "No creíamos que necesitásemos preocuparnos";
						else print "No creía que necesitase preocuparme";
					SECOND_PERSON_PAST:
						print "No era necesario que ";
						if (IsPluralNoun(player)) print "os preocupaseis";
						else print "te preocupases";
					THIRD_PERSON_PAST:
						print "No era necesario que ";
						if (IsPluralNoun(player)) print "se preocupasen";
						else print "se preocupase";
					FIRST_PERSON_FUTURE:
						print "Es difícil que";
						if (IsPluralNoun(player))
							print "vayamos a necesitar preocuparnos";
						else print "vaya a necesitar preocuparme";
					SECOND_PERSON_FUTURE:
						print "No será necesario que ";
						if (IsPluralNoun(player)) print "os preocupéis";
						else print "te preocupes";
					THIRD_PERSON_FUTURE:
						print "No será necesario que ";
						if (IsPluralNoun(player)) print "se preocupen";
						else print "se preocupe";
				}
				print " por ";
				SpanishNominativePronoun(self);
				".";
		],
 has	scenery;


!!==============================================================================
!!	Clase NPC
!!------------------------------------------------------------------------------
!!	Representa un personaje no jugador. Hay algunas librerías externas que
!!	definen sus propias clases personaje (por ejemplo, 'gtalk.h' de Greg
!!	Boettcher, Krister Fundin y Mark J. Tilford, para manejar conversaciones
!!	por medio de menús, define la clase 'Character'). Se pueden utilizar estas
!!	librerías y reutilizar las clases definidas en ellas dentro de NPC
!!	convirtiendo esta última en una subclase de aquella definida en la librería
!!	externa. Por ejemplo:
!!
!!		Class NPC
!!			class Thing
!!			class Character ! (definida en la librería *gtalk.h*)
!!			[...]
!!		;
!!
!!------------------------------------------------------------------------------

Class	NPC
 class	Thing,
 with	before [;
			DefaultAction:
				if (self has described) {
					<<TalkTo self>>;
				}
		],
 has	animate;


!!==============================================================================
!!	Clase SmartEnterable.
!!------------------------------------------------------------------------------
!!	Representa un objeto al que el jugador puede entrar o subirse encima. NOTA:
!!	Conviene recordar que Inform permite herencia múltiple. de manera que se
!!	pueden crear objetos instancias de varias clases a la vez. Por ejemplo, se
!!	pueden crear un 'Furniture' que sea además 'SmartEnterable':
!!
!!		Furniture	-> cama "cama"
!!		 class		SmartEnterable
!!		 with		[...];
!!------------------------------------------------------------------------------

Class	SmartEnterable
 with	react_before [; if (parent(player) ~= self) return false;
			!! GROUP 2 ACTIONS: Usually work, given the right circumstances.
			Close, Open:
				if (noun hasnt openable) return false;
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			Disrobe, Wear:
				if (noun hasnt clothing) return false;
				<Exit self>; new_line;
				return false;
			Drop:
				if (self has container) return false;
				if ((noun == player) || (parent(noun) ~= player)) return false;
				if (self.drop_on_object == 0) move noun to self;
				else move noun to self.drop_on_object;
				if (keep_silent == 0) print "Dejad", (o) noun, ".^";
				return true;
			Eat:
				if (noun hasnt edible) return false;
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			Empty, Remove, Search, Take:
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			EmptyT: !! TODO - Comprobar funcionamiento
				if (ObjectIsUntouchable(noun, 1)) return false;
				if (self.out_of_reach(second))
					{ <Exit self>; new_line; }
				return false;
			!Enter:
			!Examine:
			!Exit:
			!GetOff:
			!Give:
			Go:
				!! TODO - Habría que corregir el comportamiento si se
				!! implementa un sistema de movimiento no basado en puntos
				!! cardinales. (Ej: IR A <LOCALIDAD>)
				if (~~(noun ofclass CompassDirection)) return false;
				<Exit self>; new_line;
				return false;
			!GoIn:
			Insert, PutOn:
				if ((second == d_obj) || (player in second)) <<Drop noun>>;
				if (self.out_of_reach(second))
					{ <Exit self>; new_line; }
				return false;
			!Inv:
			!InvTall:
			!InvWide:
			Lock, Unlock:
				if (noun hasnt lockable) return false;
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			!Look:
			!Open:		Ver ##Close
			!Order:
			!PutOn:		Ver ##Insert
			!Remove:	Ver ##Empty
			!Search:	Ver ##Empty
			!Show:
			SwitchOff, SwitchOn:
				if (noun hasnt switchable) return false;
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			!SwitchOn:	Ver ##SwitchOff
			!Take:		Ver ##Empty
			!Transfer:
			!Unlock:	Ver ##Lock
			!VagueGo:
			!Wear:		Ver ##Disrobe
			!! GROUP 3 ACTIONS: Output a message and stop at the "before" stage.
			!Answer:
			!Ask:
			!AskFor:
			Attack, Blow, LookUnder, Smell, Squeeze, Taste, Touch:
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			!Blow:		Ver ##Attack
			!Burn:
			!Buy:
			Climb:
				if (noun hasnt enterable) return false;
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			!Consult:
			!Cut:
			!Dig:
			!Drink:
			!Fill:
			Jump:
				if (noun has supporter) <<Exit self>>;
				return false;
			!JumpOver:
			!Kiss:
			!LetGo:
			!Listen:
			!LookUnder:	Ver ##Attack
			!Mild:
			!No:
			!Pray:
			Pull, Push, Turn:
				!! TODO - Comprobar mensaje al empujar objetos scenery o static
				if (noun has scenery or static) return false;
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			!Push:		Ver ##Pull
			!PushDir:
			!Receive:
			!Rub:
			!Set:
			!SetTo:
			!Sing:
			!Sleep:
			!Smell:		Ver ##Attack
			!Sorry:
			!Squeeze:	Ver ##Attack
			!Strong:
			!Swim:
			Swing:
				if (noun has supporter) <<Swing self>>;
				return false;
			!Taste:		Ver ##Attack
			!Tell:
			!Think:
			!ThrowAt:
			!Tie:
			!Touch:		Ver ##Attack
			!Turn:		Ver ##Pull
			!Wait:
			!Wake:
			!WakeOther:
			!Wave:
			!WaveHands:
			!Yes:
			!! CUSTOM ACTIONS
			!Dance:
			GoDown:
				if (self has supporter) <<Exit self>>;
				return false;
			!GoUp:
			!KnockOn:
			!Masturbate:
			!Sit:
			!SleepWith:
			StandUp:
				if ((self has supporter) && (noun == nothing or self))
					<<Exit self>>;
			TalkTo:
				if (noun hasnt animate) return false;
				if (self.out_of_reach(noun))
					{ <Exit self>; new_line; }
				return false;
			!TalkTo:
			!Untie:
			!Use:
			!Write:
			!Xyzzy:
		],
		after [;
			Exit:
				if (keep_silent == 0) {
					if (self has supporter) {
						print "Baj", (lm_as_) player;
					} else {
						switch (_grammatical_inflection) {
							FIRST_PERSON_PRESENT:
								if (IsPluralNoun(player)) print "Salimos";
								else print "Salgo";
							SECOND_PERSON_PRESENT:
								if (IsPluralNoun(player)) print "Salís";
								else print "Sales";
							THIRD_PERSON_PRESENT:
								if (IsPluralNoun(player)) print "Salen";
								else print "Sale";
							FIRST_PERSON_PAST:
								if (IsPluralNoun(player)) print "Salimos";
								else print "Salí";
							SECOND_PERSON_PAST:
								if (IsPluralNoun(player)) print "Salisteis";
								else print "Saliste";
							THIRD_PERSON_PAST:
								if (IsPluralNoun(player)) print "Salieron";
								else print "Salió";
							FIRST_PERSON_FUTURE:
								if (IsPluralNoun(player)) print "Saldremos";
								else print "Saldré";
							SECOND_PERSON_FUTURE:
								if (IsPluralNoun(player)) print "Saldréis";
								else print "Saldrás";
							THIRD_PERSON_FUTURE:
								if (IsPluralNoun(player)) print "Saldrán";
								else print "Saldrá";
						}
					}
					print " ", (del) self, ".^";
				}
				return true;
		],
		!! Objetos al alcance desde el SmartEnterable:
		reach_objects 0,
		!! Objeto destino de la acción ##Drop estando en el SmartEnterable:
		drop_on_object 0,
 private
		!! Indica si el objeto pasado como parámetro se encuentra fuera de
		!! alcance desde el SmartEnterable. Retorna verdadero si el objeto está
		!! fuera de alcance, falso en caso contrario. [Código adaptado de la
		!! librería OutOfRch.h v2.00, de Marnie Parker <doeadeer3@aol.com>].
		out_of_reach [ obj
			top x y i;
			!! Se comprueba si el objeto se encuentra fuera de la localidad o
			!! en el interior de un contenedor cerrado:
			if (ObjectIsUntouchable(obj, true)) return false;
			!! Se comrpueba si el objeto se encuentra en el jugador o en el
			!! propio SmartEnterable:
			if (IndirectlyContains(player, obj)) return false;
			if (IndirectlyContains(self, obj)) return false;
			!! Se comprueba si el objeto es o se encuentra contenido en alguno
			!! de los reach_objects definidas:
			top = TopHolder(obj);
			if (metaclass(self.&reach_objects-->0) == Routine) {
				x = self.reach_objects();
				if (x == top) return false;
			}
			if (metaclass(self.&reach_objects-->0) == Object or Class) {
				y = self.#reach_objects;
				for (i = 0 : i < (y/2) : i++) {
					x = self.&reach_objects-->i;
					if (x == top) return false;
				}
			}
			!! El objeto se encuentra fuera del alcance:
			return true;
		],
 has	enterable;
