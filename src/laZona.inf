!% -~S~D
!% +language_name=Spanish
!% $list


!!==============================================================================
!!
!!	LA ZONA
!!
!!==============================================================================
!!
!!	Archivo:		laZona.inf
!!	Autor(es):		J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Idioma:			ES (Castellano)
!!	Sistema:		Inform-INFSP 6
!!	Plataforma:		Máquina-Z/Glulx
!!	Versión:		1.0
!!	Fecha:			2018/08/25
!!
!!------------------------------------------------------------------------------
!!
!!	Este archivo forma parte de la ficción interactiva LA ZONA.
!!
!!	LA ZONA es software libre: usted puede redistribuirlo y/o
!!	modificarlo bajo los términos de la Licencia Pública General GNU
!!	publicada por la Fundación para el Software Libre, ya sea la versión
!!	3 de la Licencia, o (a su elección) cualquier versión posterior.
!!
!!	LA ZONA se distribuye con la esperanza de que sea útil, pero
!!	SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita MERCANTIL o
!!	de APTITUD PARA UN PROPÓSITO DETERMINADO. Consulte los detalles de
!!	la Licencia Pública General GNU para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública General GNU
!!	junto a LA ZONA. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (c) 2018, J. Francisco Martín
!!
!!------------------------------------------------------------------------------
!!
!!	HISTORIAL DE VERSIONES
!!
!!	0.0: 2016/06/18	Inicio del desarrollo.
!!
!!------------------------------------------------------------------------------
!!
!!	TABLA DE CONTENIDOS
!!
!!	1)	Constantes y variables globales de la obra
!!	2)	Reemplazos de rutinas utilizadas por la librería Inform
!!	3)	Librerías y extensiones (parte 1 de 2)
!!	4)	Puntos de entrada Glk con GWindows (sólo en GLULX)
!!	5)	Librerías y extensiones (parte 2 de 2)
!!	6)	Puntos de entrada de la obra
!!	7)	Otras rutinas
!!	8)	Gramática estándar y extendida
!!	9)	Definición de atributos, clases y objetos
!!
!!------------------------------------------------------------------------------


!!==============================================================================
!!
!!	1)	Constantes y variables globales de la obra
!!
!!------------------------------------------------------------------------------
!!	<>	Información bibliográfica
!!	<>	Definiciones generales
!!	<>	Definiciones de la librería Inform
!!	<>	Configuración de la interfaz gráfica con 'GWindows'
!!	<>	Configuración de la extensión 'hyperlinks'
!!	<>	Configuración de la librería de mensajes 'SpanishLM'
!!	<>	Configuración de la extensión 'textStyles'
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Información bibliográfica.
!!------------------------------------------------------------------------------

Constant Story
"LA ZONA";

Constant Headline
"Una ficción interactiva. Copyright (c) 2018^
Por J. Francisco Martín";

Constant Checking 1;
Release 0; Serial "180825";					! v0.0

!!------------------------------------------------------------------------------
!! Definiciones generales
!!------------------------------------------------------------------------------

!! Utilización del gestor de audio Damusix:
Constant USE_DAMUSIX;
!! Utilización de extensiones a las rutinas por defecto de la librería:
Constant USE_EXTENDED_LIBRARY;
!! Utilización de interfaz gráfica GWindows:
Constant USE_GWINDOWS;
!! Utilización de hipervínculos Glk:
Constant USE_HYPERLINKS;
!! Utilización de mensajes personalizados de la librería:
Constant USE_SPANISH_LM;

!! Nombre del fichero de configuración:
Constant CONFIG_FILE_NAME "laZona.cconfig";

!! Estado de los hipervínculos:
Constant DEFAULT_HYPERLINKS_STATUS 1;

!! Estilos de texto por defecto para las palabras destacadas:
Constant DEFAULT_HIGHLIGHT_ST_1 TEXT_STYLE_USER1;
Constant DEFAULT_HIGHLIGHT_ST_2 TEXT_STYLE_STRESSED;
Constant DEFAULT_HIGHLIGHT_ST_3 TEXT_STYLE_UPRIGHT;

!!------------------------------------------------------------------------------
!!	Definiciones de la librería Inform
!!------------------------------------------------------------------------------

!! Los pronombres se refieren a objetos ya mencionados previamente:
Constant MANUAL_PRONOUNS;
!! Número máximo de objetos que el PC (player character) puede llevar en mano:
Constant MAX_CARRIED 3;
!! Las acciones LUGARES y OBJETOS están desactivadas:
Constant NO_PLACES;
!! No se lleva conteo de puntuación:
Constant NO_SCORE;

#Ifdef USE_SPANISH_LM;
!! Se omiten los mensajes por defecto de la librería Inform:
Constant SIN_MENSAJES;
#Endif; ! USE_SPANISH_LM;

#Ifdef USE_EXTENDED_LIBRARY;
!! Se omiten las direcciones por defecto de la librería Inform:
Constant WITHOUT_DIRECTIONS;
#Endif; ! USE_EXTENDED_LIBRARY;

!!------------------------------------------------------------------------------
!!	Configuración de la interfaz gráfica con 'GWindows' (sólo en Glulx)
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
!! Color de los márgenes de la interfaz:
Constant GUICONFIG_MARGIN_COLOR $FFFFFF;
!! Distribución de ventanas:
Object	GUIConfig "(GUI Configuration)"
 with	!!----------------------------------------------------------------------
		graphic_window_flag true,	! estado de las ventanas gráficas
		status_bar_height 1,		! altura de la barra de estado (en filas)
		!!----------------------------------------------------------------------
		!! Configuración por defecto A. Ancho de ventana >= threshold_A
		graphic_width_A 0 0,	! (px)
		margin_A 0 0,			! (%)
		padding_A 0 0 8 0,		! (px)
		threshold_A 0,			! (px)
		!! Configuración por defecto B. Ancho de ventana >= threshold_B
		graphic_width_B 0 0,	! (px)
		margin_B 0 6,			! (%)
		padding_B 0 0 8 0,		! (px)
		threshold_B 460,		! (px)
		!! Configuración por defecto C. Ancho de ventana >= threshold_C
		graphic_width_C 0 0,	! (px)
		margin_C 0 12,			! (%)
		padding_C 0 0 8 0,		! (px)
		threshold_C 660,		! (px)
		!! Configuración por defecto D. Ancho de ventana >= threshold_D
		graphic_width_D 225 0,	! (px)
		margin_D 0 4 0 16,		! (%)
		padding_D 0 18 8 0,		! (px)
		threshold_D 900,		! (px)
		!! Configuración por defecto E. Ancho de ventana >= threshold_E
		graphic_width_E 225 0,	! (px)
		margin_E 0 4 0 20,		! (%)
		padding_E 0 20 8 0,		! (px)
		threshold_E 1050,		! (px)
		!! Configuración por defecto F. Ancho de ventana >= threshold_F
		graphic_width_F 300 0,	! (px)
		margin_F 0 6 0 24,		! (%)
		padding_F 0 40 8 0,		! (px)
		threshold_F 1224,		! (px)
		!! Configuración por defecto G. Ancho de ventana >= threshold_G
		graphic_width_G 340 0,	! (px)
		margin_G 0 6 0 32,		! (%)
		padding_G 0 20 8 0,		! (px)
		threshold_G 1400,		! (px)
;
#Endif; ! TARGET_

!!------------------------------------------------------------------------------
!!	Configuración de la extensión 'hyperlinks'
!!------------------------------------------------------------------------------

#Ifdef USE_HYPERLINKS;
!! Acción por defecto utilizada al seleccionar un hipervínculo:
Global _hyperlinks_command = "";
#Endif; ! USE_HYPERLINKS;

!!------------------------------------------------------------------------------
!!	Configuración de la librería de mensajes 'SpanishLM'
!!------------------------------------------------------------------------------

#Ifdef USE_SPANISH_LM;
Global PS1			= "^> "; ! Inductor
Global FORMER__TX	= "tu antiguo ~yo~";
Global YOURSELF__TX	= "ti mismo";
Global CANTGO__TX	= "No puedes ir por ahí.";
Global IS__TX		= " ves";
Global ARE__TX		= " ves";
Global IS2__TX		= "ves ";
Global ARE2__TX		= "ves ";
Global YOU__TX		= "Tú";
Global PARTICULA_TE	= "te";
#Endif; ! USE_SPANISH_LM;

!!------------------------------------------------------------------------------
!!	Configuración de la extensión 'textStyles'
!!------------------------------------------------------------------------------

!! Color frontal para el estilo de texto encabezado:
Constant HEADER_STYLE_FGC $8596aa; ! #8596aa
!! Color de fondo del estilo de texto Usuario 1:
Constant USR1_STYLE_BGC	$e0e0e0; ! #e0e0e0
!! Color frontal del estilo de texto Usuario 2:
Constant USR2_STYLE_FGC $808080; ! #808080

#Ifdef TARGET_ZCODE;
Constant TEXT_STYLE_PARSER TEXT_STYLE_MONOSPACED;
#Ifnot; ! TARGET_GLULX;
Constant TEXT_STYLE_PARSER TEXT_STYLE_USER2;
#Endif; ! TARGET_

Constant TEXT_STYLE_PARSER_PREFIX "[";
Constant TEXT_STYLE_PARSER_SUFIX "]";


!!==============================================================================
!!
!!	2)	Reemplazos de rutinas utilizadas por la librería Inform
!!
!!------------------------------------------------------------------------------

#Ifdef USE_SPANISH_LM;
Replace ChangePlayer;			! Rutina para cambiar el objeto PC
#Endif; ! USE_SPANISH_LM;

#Ifdef USE_EXTENDED_LIBRARY;
Replace Banner;					! Créditos generales de la aplicación
Replace DrawStatusLine;			! Dibuja la barra de estado
Replace ExamineSub;				! Rutina para la acción ##Examine
Replace GetGNAOfObject;			! Rutina para obtener el GNA de un objeto
Replace LanguageDirection;		! Imprime el nombre de las direcciones
Replace LMode1Sub;				! Lookmode 1: Breve
Replace LMode2Sub;				! Lookmode 2: Largo (establecido por defecto)
Replace LMode3Sub;				! Lookmode 3: Superbreve
Replace LookSub;				! Rutina para la acción ##Look
Replace PSN__;					! Rutina para imprimir nombre corto de un obj.
Replace VersionSub;				! Créditos detallados de la aplicación
#Endif; ! USE_EXTENDED_LIBRARY;

#Ifdef USE_HYPERLINKS;
Replace HyperlinkSetStyle;		! Gestión de estilos de texto de hipervínculos
Replace HyperlinkStatus;		! Gestión de estado de hipervínculos
#Endif; ! USE_HYPERLINKS;


!!==============================================================================
!!
!!	3)	Librerías y extensiones (parte 1 de 2)
!!
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef USE_GWINDOWS;
Include "gwindefs.h";			! GWindows: Definiciones
#Endif; ! USE_GWINDOWS;
#Endif; ! TARGET_GLULX;

Include "Parser.h";				! Decodifica la entrada del teclado
Include "textStyles.h";			! Selección de estilo de los textos

#Ifdef USE_SPANISH_LM;
Include "SpanishLM.h";			! Mensajes de la librería
#Endif; ! USE_SPANISH_LM;

#Ifdef USE_EXTENDED_LIBRARY;
Include ">laZona_lib.inf";		! Personalizaciones de la librería Inform
#Endif; ! USE_EXTENDED_LIBRARY;

Include ">laZona_langLM.inf";	! Mensajes personalizados de la librería
Include ">laZona_langOM.inf";	! Mensajes de los objetos

#Ifdef TARGET_GLULX;
#Ifdef USE_GWINDOWS;
Include "gwincls.h";			! GWindows: Window Class Framework
#Endif; ! USE_GWINDOWS;
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!
!!	4)	Puntos de entrada Glk con GWindows (sólo en GLULX)
!!
!!------------------------------------------------------------------------------
!!	<>	HandleGlkEventExe() / HandleGlkEvent() / GWindowsGlkEvent()
!!	<>	IdentifyGlkObjectExe() / IdentifyGlkObject() / GWindowsGlkIdentify()
!!	<>	InitGlkWindowExe() / InitGlkWindow() / InitGWindows()
!!
!! NOTA: GWindows hace uso de los puntos de entrada Glk por defecto, por lo
!! cuál define los suyos propios para reemplazar aquellos de la librería.
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
!!------------------------------------------------------------------------------
!! Punto de entrada para manejar eventos Glk.
!!
!!	@param {array} ev - Array de 4 palabras que describe el evento. ev-->0
!!		registra un código numérico con que se determina el tipo de evento. La
!!		rutina sólo actúa si se trata de un evento de tipo hipervínculo
!!		(ev-->0 == 8); ev-->1 indica la ventana sobre la que se ha producido el
!!		evento; ev-->2 el objeto o cadena de caracteres sobre el que se ha
!!		creado el hipervínculo; ev-->3, reservado para información adicional,
!!		no se utiliza
!!	@param {integer} context - 0 si el evento se ha producido durante una
!!		entrada de línea (comandos normales u otros usos de la función de la
!!		librería 'KeyboardPrimitive()'); la aplicación debe esperar a que el
!!		usuario pulse INTRO antes de dar respuesta para la entrada. 1 si el
!!		evento se ha producido durante una entrada de caracter (función de la
!!		librería 'KeyCharPrimitive()'); la aplicación responde ante cada
!!		pulsación de tecla, como en los menús, por ejemplo
!!	@param {array} abortres - Utilizado para cancelar la entrada de texto y
!!		forzar una entrada particular. La longitud de la nueva entrada se
!!		registra en 'abortres-->0'. Si es diferente de 0, los caracteres del
!!		comando deben escribirse en el array secuencialmente desde la posición
!!		'abortres->WORDSIZE' hasta 'abortres->(WORDSIZE+length)' (no
!!		inclusive). No pueden superarse los 256 caracteres
!!	@returns {integer|boolean} 2 para que la entrada de usuario sea abortada.
!!		-1 para que la entrada de usuario continúe incluso después de una
!!		pulsación de INTRO (para las entradas de línea) o de tecla (para las
!!		entradas de caracter). Cualquier otro valor de retorno continuará con
!!		la ejecución normal de la librería
!!------------------------------------------------------------------------------
#Ifdef USE_GWINDOWS;
[ GWindowsGlkEvent ev context abortres;
 	return HandleGlkEventExe(ev, context, abortres);
];
#Ifnot;
[ HandleGlkEvent ev context abortres;
 	return HandleGlkEventExe(ev, context, abortres);
];
#Endif; ! USE_GWINDOWS;
[ HandleGlkEventExe ev context abortres;
	!! Gestión de efecto de 'fade' en Damusix en tiempo real:
	#Ifdef USE_DAMUSIX;
	Damusix.NotificarFade(ev);
	#Endif; ! USE_DAMUSIX;

	!! Gestión de los eventos de selección de hipervínculo:
	#Ifdef USE_HYPERLINKS;
	if (HandleHyperlinkEvent(ev, context, abortres)) {
		return 2; ! finaliza el turno
	}
	#Endif; ! USE_HYPERLINKS
];

!!------------------------------------------------------------------------------
!! 'IdentifyGlkObject()' permite conocer qué objetos Glk existen; útil para
!! gestionar las directivas RESTORE, RESTART y UNDO puesto que, tras utilizar
!! estas entradas, las variables globales con objetos Glk pueden contener
!! valores desfasados y erróneos.
!!
!!	@param {integer} phase - Código numérico indicando la fase en la que se
!!		invoca a la rutina. Toma los valores: 0, 1 o 2
!!	@param {integer} type - 0, 1 o 2 para ventanas, 'streams' y 'filerefs',
!!		respectivamente
!!	@param {Object} ref
!!	@param {integer} rock
!!------------------------------------------------------------------------------
#Ifdef USE_GWINDOWS;
[ GWindowsGlkIdentify phase type ref rock;
	return IdentifyGlkObjectExe(phase, type, ref, rock);
];
#Ifnot;
[ IdentifyGlkObject phase type ref rock;
	return IdentifyGlkObjectExe(phase, type, ref, rock);
];
#Endif; ! USE_GWINDOWS;
[ IdentifyGlkObjectExe phase type ref rock;
	!! Se identifican todos los objetos de sonido gestionados por Damusix:
	#Ifdef USE_DAMUSIX;
	Damusix.IdentificarSonidos(phase);
	#Endif; ! USE_DAMUSIX;

	phase = type + ref + rock; ! (por evitar alertas del compilador)
];

!!------------------------------------------------------------------------------
!! 'InitGlkWindow()' es un punto de entrada es invocado por la librería cuando
!! establece las ventanas por defecto: la ventana de texto principal, la
!! ventana de estado y la ventana para caja de citas (en caso de utilizarlas).
!! La ventana de texto principal y la ventana de estado son creadas al iniciar
!! la aplicación (antes de 'Initialise()'). La ventana de citas es creada y
!! destruida según se necesite. Este punto de entrada es invocado en 5 fases:
!!
!!	1)	Al inicio de la ejecución (antes incluso del punto de entrada
!!		'Initialise()') se hace la invocación 'InitGlkWindow(0)'. Aquí se
!!		pueden efectuar cualesquiera inicializaciones de ventanas Glk (se debe
!!		tener en cuenta, no obstante, que las ventanas de texto principal y de
!!		estado pueden estar ya inicializadas ---por ejemplo si el usuario acaba
!!		de utilizar la instrucción RESTART---). Este es un buen momento para
!!		establecer 'gg_statuswin_size' a un valor distinto de 1. Retornar 0
!!		para proceder con el resto de inicializaciones de ventanas por defecto
!!		de la librería, o 1 si ya se han inicializado todas las ventanas
!!		manualmente.
!!	2)	La librería invoca a 'InitGlkWindow(GG_MAINWIN_ROCK)' antes de crear la
!!		ventana de texto principal. Este es un buen momento para inicializar
!!		las recomendaciones de aspecto de la ventana de texto. Retornar 0 para
!!		permitir que la librería continúe normalmente con la creación de la
!!		ventana, o 1 si la ventana ya se ha creado y registrado en la variable
!!		'gg_mainwin' manualmente.
!!	3)	La librería invoca a 'InitGlkWindow(GG_STATUSWIN_ROCK)' antes de crear
!!		la ventana de estado. De nuevo, se puede retornar 0 para permitir que
!!		la librería cree la ventana normalmente, o 1 si la ventana ya se ha
!!		creado y registrado en la variable 'gg_statuswin' manualmente.
!!	4)	Al final de la inicialización de las ventanas Glk se invoca
!!		'InitGlkWindow(1)'. En este momento se pueden abrir otras ventanas Glk
!!		(o pueden abrirse igualmente en la rutina 'Initialise()').
!!	5)	La librería invoca 'InitGlkWindow(GG_QUOTEWIN_ROCK)' antes de crear la
!!		ventana de caja de citas. Esto no ocurre durante la inicialización de
!!		la aplicación sino durante la ejecución, siempre que se efectúe una
!!		impresión en la caja de citas, y la ventana es destruída después un
!!		turno más tarde. Como siempre, se puede retornar 1 para indicar que la
!!		ventana ya ha sido creada y registrada en 'gg_quotewin' manualmente.
!!		(El número de líneas deseadas para la ventana puede consultarse en
!!		'gg_arguments-->0').
!!
!! Independientemente de la forma en que se gestione la inicialización de las
!! ventanas, debe tenerse en cuenta que la librería requiere de una ventana
!! principal registrada en 'gg_mainwin'. En caso de no crear una manualmente y
!! no permitir que la librería lo haga de manera automática, la aplicación se
!! cerrará. Las ventanas de estado y de caja de citas, por el contrario, son
!! completamante opcionales; la librería se comportará correctamente sin ellas.
!!
!! La librería GWindows hace uso del punto de entrada 'InitGlkWindow()'. En su
!! lugar, ofrece el punto de entrada 'InitGlkWindow()', sin argumentos, que es
!! equivalente a invocar 'InitGlkWindow(0)'. Debe establecer las variables
!! 'Active_UI', con la raíz del árbol de ventanas; y 'Main_GWindow', con el
!! objeto 'GWindow' que sirve de ventana principal de la aplicación. Se cumple
!! que la variable: 'gg_mainwin == Main_GWindow.winid'.
!!
!!	@param {integer} winrock
!!	@returns {integer}
!!------------------------------------------------------------------------------
#Ifdef USE_GWINDOWS;
[ InitGWindows;
	!! Inicializaciones de la interfaz gráfica GWindows:
	Active_UI = rootUI;
	Main_GWindow = textWindow;
	return InitGlkWindowExe(GG_MAINWIN_ROCK);
];
#Ifnot;
[ InitGlkWindow winrock;
	return InitGlkWindowExe(winrock);
];
#Endif; ! USE_GWINDOWS;
[ InitGlkWindowExe winrock
	wintype;
	if (winrock == GG_MAINWIN_ROCK) {
		!! [0:wintype_AllTypes, 1:wintype_Pair, 2:wintype_Blank,
		!! 3:wintype_TextBuffer, 4:wintype_TextGrid, 5:wintype_Graphics]
		wintype = 0;

	    !! Sugerencias de aspecto de 'textStyles':
	    InitialiseStyleHints(winrock, wintype);

		#Ifdef HEADER_STYLE_FGC;
		glk($00B0, 0, 3, 7, HEADER_STYLE_FGC); ! header: stylehint_TextColor
		#Endif; ! HEADER_STYLE_FGC

		!! Propuestas de estilo de texto personalizado: Usuario 1
		#Ifdef USR1_STYLE_FGC;
		glk($00B0, 0, 9, 7, USR1_STYLE_FGC); ! glk_stylehint_set()
		#Endif; ! USR1_STYLE_FGC;
		#Ifdef USR1_STYLE_BGC;
		glk($00B0, 0, 9, 8, USR1_STYLE_BGC); ! glk_stylehint_set()
		#Endif; ! USR1_STYLE_BGC;

		!! Propuestas de estilo de texto personalizado: Usuario 2
		#Ifdef USR2_STYLE_FGC;
		glk($00B0, 0, 10, 7, USR2_STYLE_FGC); ! glk_stylehint_set()
		#Endif; ! USR2_STYLE_FGC;
		#Ifdef USR2_STYLE_BGC;
		glk($00B0, 0, 10, 8, USR2_STYLE_BGC); ! glk_stylehint_set()
		#Endif; ! USR2_STYLE_BGC;
	}
    !! Se continúa con el proceso normal de la librería:
    return false;
];
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!
!!	5)	Librerías y extensiones (parte 2 de 2)
!!
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef USE_DAMUSIX;
Include "damusix.h";			! Administrador unificado de sonido en GLULX
#Endif; ! USE_DAMUSIX;

#Ifdef USE_GWINDOWS;
Include "gwindows.h";			! GWindows: Reemplazos de la librería
Include "gWindowsGUI.h";		! Interfaz gráfica adaptativa con GWindows
#Endif; ! USE_GWINDOWS;

Include ">laZona.bli";			! Recursos multimedia de la aplicación
#Ifnot; ! TARGET_ZCODE;
Constant PIC_INFIERNO_A 0;
Constant PIC_INFIERNO_B 1;
Constant PIC_TUNEL_A 2;
Constant PIC_CANAL_A 3;
Constant PIC_CANAL_B 4;
Constant PIC_CALLEJON_A 5;
Constant PIC_CALLEJON_B 6;
Constant PIC_AZOTEA_A 7;
Constant PIC_AZOTEA_B 8;
Constant PIC_CALLE_A 9;
Constant PIC_CALLE_B 10;
Constant PIC_CADAVER 11;
Constant MUS_INFIERNO 0;
Constant MUS_PURGATORIO 1;
Constant SFX_GOTAS 2;
Constant SFX_VIENTO 3;
#Endif; ! TARGET_

Include "arrays.h";				! Operaciones con arrays
Include "pPreprocessor.h";		! Preprocesador del parser
Include "shuffle.h";			! Barajeado de números aleatorios

#Ifdef USE_HYPERLINKS;
Include	"hyperlinks.h";			! Rutinas de apoyo para el uso de hipervínculos
#Endif; ! USE_HYPERLINKS;

Include "VerbLib.h";			! Define cómo trabajan las acciones


!!==============================================================================
!!
!!	6)	Puntos de entrada del relato
!!
!!------------------------------------------------------------------------------
!!	<>	AfterPrompt()
!!	<>	BeforeParsing()
!!	<>	Initialise()
!!	<>	InScope()
!!	<>	PrintVerb()
!!	<>	UnknownVerb()
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Punto de entrada invocado justo tras la impresión del inductor (prompt); es
!! decir, después de que todas las impresiones en pantalla derivadas del turno
!! actual hayan finalizado. Se encarga de gestionar los cambios de imagen de la
!! ventana gráfica (en GLULX).
!!
!!	@returns Nada
!!------------------------------------------------------------------------------
Global _current_location = 0;
[ AfterPrompt
	i;
	#Ifdef TARGET_GLULX;
	if (_current_location == real_location) return;
	_current_location = real_location;
	if (location provides images) {
		i = random((location.#images)/WORDSIZE) - 1;
		DrawSceneImage(location.&images-->i);
	}
	!! XXX - Se fuerza un cambio de imagen concreto:
	if (location == CalleCentro && Cuerpo.shot)
		DrawSceneImage(PIC_CADAVER);
	#Endif; ! TARGET_GLULX;
];

!!------------------------------------------------------------------------------
!! Permite manipular la entrada de usuario antes de que sea analizada por la
!! librería. Es invocada después de que el sistema haya leído la entrada de
!! texto y haya definido ya las tablas 'buffer' y 'parser', pero aún no ha
!! hecho nada más salvo establecer el contador de palabras 'wn' a 1. La rutina
!! puede manipular estas tablas libremente mientras permanezcan consistentes la
!! una con la otra, y puede dejar el contador de palabras en cualquier punto.
!!
!!	@returns Nada
!!------------------------------------------------------------------------------
[ BeforeParsing;
	#Ifdef TARGET_GLULX;
	ParsingPreprocessor.run();
	#Endif; ! TARGET_GLULX;
];

!!------------------------------------------------------------------------------
!! Inicializaciones del relato. Esta rutina es obligatoria y, entre otras
!! posibles inicializaciones, DEBE ESTABLECER LA LOCALIDAD INICIAL del usuario
!! (o el objeto accesible sobre o dentro del que empieza).
!!
!!	@returns {boolean|integer} Verdadero o falso para continuar con la
!!		ejecución normal de la aplicación, o 2 para suprimir la impresión de
!!		los créditos, que de otra manera se imprimirían inmediatamente después
!!		de llamar a la rutina
!!------------------------------------------------------------------------------
[ Initialise
	initial_location;

	!! Comprobaciones del intérprete -------------------------------------------
	#Ifdef TARGET_GLULX;
	!! Comprobaciones de las capacidades multimedia:
	if (~~(glk_gestalt(gestalt_Sound, 0) && glk_gestalt(gestalt_SoundMusic, 0)
		&& glk_gestalt(gestalt_Graphics, 0))) {
		print (strong) "ADVERTENCIA:", " Esta aplicación incluye contenidos
		gráficos y de audio, pero tu intérprete GLULX no los soporta
		adecuadamente. La aplicación se iniciará con parte o la totalidad de
		sus recursos multimedia desactivados.^";
		new_line;
		print (parser) "Pulsa una tecla para continuar.";
		PressAnyKey();
		EraseWindow();
	}
	#Endif; ! TARGET_GLULX;

	!! Inicializaciones para la VM Glulx ---------------------------------------
	#Ifdef TARGET_GLULX;
	!! Establece la escucha de eventos glk para el uso de hipervínculos:
	#Ifdef USE_HYPERLINKS;
	ListenHyperlinkEvents();
	#Endif; ! USE_HYPERLINKS;
	!! Inicializa los canales de audio (10 reales + 10 virtuales):
	!!	-	SONIDO: Recurso de sonido declarado en el fichero '.res'
	!!	-	CANAL: Número del canal [0-9]
	!!	-	PORCENTAJE DE VOLUMEN: [0-100]. -1 para usar el volumen global
	!!	-	NÚM. DE REPETICIONES: (Opcional) 1 por defecto. -1 para infinitas
	Damusix.AsignarCanal(MUS_INFIERNO, 0, 100, -1);
	Damusix.AsignarCanal(MUS_PURGATORIO, 1, 100, -1);
	Damusix.AsignarCanal(SFX_GOTAS, 2, 100, -1);
	Damusix.AsignarCanal(SFX_VIENTO, 3, 75, -1);
	!! Lee el fichero de configuración:
	DM.read_configuration_file(CONFIG_FILE_NAME);
	#Endif; ! TARGET_

	!! Inicializaciones de la obra ---------------------------------------------
	!! Narrador en presente y tercera persona:
	DM.set_grammatical_inflection(THIRD_PERSON_PRESENT);
    !! Reproduce la pista de audio del menú:
    FadeInTrack(MUS_INFIERNO, -1, 0);
	!! Se lanza el menú antes de establecer al PC (player character) para
	!! evitar que se imprima un nombre de localidad en la barra de estado:
	initial_location = MainMenu();
	!! Establece el PC:
	ChangePlayer(Stalker);
	!! Establece la localidad inicial de la obra:
	location = initial_location;
	!! Lookmode largo:
	lookmode = 2;

	new_line;
	print (parser) "Puedes cambiar la configuración de los hipervínculos y el
	resaltado de objetos en cualquier momento introduciendo el comando
	@<<CONFIGURACIÓN@>> (o @<<CONFIG@>>).", "^";
	new_line;
	HorizontalRule();
	new_line;

	return 2;
];

!!------------------------------------------------------------------------------
!! Definición del foco del usuario; permite cambiar en el sistema la definición
!! de lo que se encuentra al alcance del PJ. Utiliza las rutinas de la librería
!! 'ScopeWithin()' y 'PlaceInScope()' para establecer cuál debería ser el foco.
!!
!!	@returns {boolean} Falso para indicar al sistema que añada todos los
!!		objetos que suelen estar por defecto al alcance, o verdadero para
!!		indicar que no se debe añadir nada más al alcance
!!------------------------------------------------------------------------------
[ InScope person
	item;
	!! Aseguramos que la localidad actual esté siempre en el foco del PJ:
	PlaceInScope(real_location);
	!! En la oscuridad, se mueven al foco todos aquellos objetos que hayan sido
	!! manipulados ya previamente por el PJ:
	if ((person == player) && (location == thedark)) {
		objectloop(item in parent(self))
			if (item has moved) PlaceInScope(item);
	}

	return false;
];

!!------------------------------------------------------------------------------
!! Permite cambiar el verbo que imprime el sistema al hacer al usuario
!! preguntas del tipo: "Intenta de nuevo porque sólo se pudo entender que
!! quieres <lo que sea>.", en caso de que se haya definido alguna acción
!! inusual por medio de la rutina 'UnknownVerb()'.
!!
!!	@param {address} word - Dirección de diccionario del verbo
!!	@returns {boolean} Verdadero para indicar al sistema que se ha imprimido la
!!		forma modificada del verbo, o falso para continuar con la ejecución
!!		normal y que el sistema imprima el verbo de la forma habitual
!!------------------------------------------------------------------------------
[ PrintVerb word;
	if (word == 'no.verb') {
		print "hacer algo con";
		return true;
	}

	return false;
];

!!------------------------------------------------------------------------------
!! Invocada por el sistema cuando se encuentra con un verbo desconocido, de
!! forma que pueda cambiarse por uno definido en el relato. Se utiliza para
!! contemplar las siguientes situaciones:
!!
!! 1) Desplazarse automáticamente a una localidad adyacente a la localidad
!! actual tecleando simplemente su nombre.
!!
!! 2) Lanzar una acción por defecto sobre un objeto cuando se teclea únicamente
!! su nombre. En este caso se sigue la implementación propuesta en
!! <http://rec.arts.int-fiction.narkive.com/Cz9j184N/inform-6-parser-question>,
!! con modificaciones para que sólo se intente lanzar la acción sobre objetos
!! que existen realmente y están presentes dentro del foco del PJ. De otra
!! forma, siempre se intentaría lanzar la acción ##DefaultAction aún cuando la
!! intención del usuario no fuese manipular un objeto sino utilizar una acción
!! que en realidad no está definida. (Tenemos que asegurarnos de que la
!! localidad actual se encuentra dentro del foco del PJ para que el usuario
!! pueda referirse a ella ---ver rutina 'InScope()'---).
!!
!!	@returns {boolean} Falso para permitir que el sistema continúe con la
!!		ejecución normal e imprima un mensaje de error, o un valor de
!!		diccionario del verbo a utilizar en lugar del verbo desconocido
!!------------------------------------------------------------------------------
[ UnknownVerb
	obj;
	obj = ParsingPreprocessor.get_selected_object();
	if (TestScope(obj, player)) {
		verb_wordnum = 0;
		return 'no.verb';
	}

	return false;
];


!!==============================================================================
!!
!!	7)	Otras rutinas
!!
!!------------------------------------------------------------------------------
!!	<>	ConfigureHyperlinks()
!!	<>	ConfigureHighlightStyle()
!!	<>	DrawSceneImage()
!!	<>	EraseWindow()
!!	<>	FadeInTrack()
!!	<>	FadeOutTrack()
!!	<>	HorizontalRule()
!!	<>	HyperlinkSetStyle()
!!	<>	HyperlinkStatus()
!!	<>	IsTrackPlaying()
!!	<>	MainMenu()
!!	<>	PressAnyKey()
!!	<>	PrintCentered()
!!	<>	PSN__()
!!	<>	SpanishNominativePronoun()
!!	<>	SpanishNominativePronounCap()
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Permite al usuario activar/desactivar los hipervínculos para cada uno de los
!! diferentes conjuntos de objetos de la aplicación.
!!
!!	@param {string} [txt = 0] - Cadena de texto que se imprime al final del
!!		menú. Debe ser algo similar a: "Pulsa INTRO para aceptar."
!!	@returns {boolean} Verdadero
!!	@version 1.1
!!------------------------------------------------------------------------------
[ ConfigureHyperlinks txt
	done previous_style i;
	while (done == false) {
		EraseWindow();
		new_line;
		previous_style = DM.set_text_style(TEXT_STYLE_HEADER);
		print (string) Story;
		DM.set_text_style(previous_style);
		print " utiliza un sistema de hipervínculos para facilitar la
		interacción con los objetos presentes en la obra a través del ratón.
		Hay tres clases de hipervínculo: 1) asociado a objetos importantes en
		la historia, 2) objetos o direcciones hacia los que te puedes
		desplazar, 3) otros objetos interactivos. Puedes activar o desactivar
 		cada tipo de hipervínculo introduciendo el número de su clase:";
		new_line;
		new_line;
		for (i = 1 : i <= 3 : i++) {
			switch (i) {
				1:	print "1) Objetos importantes: ";
				2:	print "2) Direcciones: ";
				3:	print "3) Otros objetos: ";
			}
			if (DM.get_hyperlinks_status(i)) print "@<<activados@>>";
			else print (user2) "@<<desactivados@>>";
			print ".";
			new_line;
		}
		if (txt ~= 0) {
			new_line;
			previous_style = DM.set_text_style(TEXT_STYLE_PARSER);
			print (string) TEXT_STYLE_PARSER_PREFIX;
			print (string) txt;
			print (string) TEXT_STYLE_PARSER_SUFIX;
			DM.set_text_style(previous_style);
		}
		switch (PressAnyKey()) {
			32, -6: done = true; ! Código de INTRO/ESPACIO
			'1': DM.set_hyperlinks_status(1, ~~DM.get_hyperlinks_status(1));
			'2': DM.set_hyperlinks_status(2, ~~DM.get_hyperlinks_status(2));
			'3': DM.set_hyperlinks_status(3, ~~DM.get_hyperlinks_status(3));
		}
	}
	EraseWindow();
	return true;
];

!!------------------------------------------------------------------------------
!! Permite al usuario modificar el estilo con el que se imprimen las palabras
!! clave para cada uno de los diferentes conjuntos de objetos de la aplicación.
!!
!!	@param {string} [txt = 0] - Cadena de texto que se imprime al final del
!!		menú. Debe ser algo similar a: "Pulsa INTRO para aceptar."
!!	@returns {boolean} Verdadero
!!	@version 1.1
!!------------------------------------------------------------------------------
[ ConfigureHighlightStyle txt
	done i highlight temp previous_style;
	while (done == false) {
		EraseWindow();
		new_line;
		print "Puedes, además, modificar el aspecto con el que se imprimen los
		nombres de los objetos interactivos de la obra ---incluso aunque los
		hipervínculos estén desactivados---. Introduce el número de la clase de
		palabra destacada para rotar entre los distintos estilos de resaltado
		disponibles y seleccionar aquel que se adecue mejor a tus preferencias
		personales:";
		new_line;
		new_line;
		for (i = 1 : i <= 3 : i++) {
			switch (i) {
				1:	print "1) Objetos importantes: ";
				2:	print "2) Direcciones: ";
				3:	print "3) Otros objetos: ";
			}
			highlight = DM.get_highlight_style(i);
			temp = ~~DM.get_hyperlinks_status(i);
			switch (highlight) {
				TEXT_STYLE_UPRIGHT:
					Hyperlink("sin estilo", 0, highlight, temp);
				TEXT_STYLE_STRESSED:
					Hyperlink("enfatizado (a)", 0, highlight, temp);
				TEXT_STYLE_NOTE:
					Hyperlink("enfatizado (b)", 0, highlight, temp);
				TEXT_STYLE_IMPORTANT:
					Hyperlink("destacado (a)", 0, highlight, temp);
				TEXT_STYLE_HEADER:
					Hyperlink("destacado (b)", 0, highlight, temp);
				TEXT_STYLE_MONOSPACED:
					Hyperlink("monoespaciado", 0, highlight, temp);
				TEXT_STYLE_REVERSED:
					Hyperlink("invertido", 0, highlight, temp);
				TEXT_STYLE_USER1:
					Hyperlink("color de fondo", 0, highlight, temp);
			}
			print ".";
			new_line;
		}
		new_line;
		print "NOTA: Cuando los hipervínculos están desactivados hay menos
		opciones de estilos disponibles.";
		new_line;
		if (txt ~= 0) {
			new_line;
			previous_style = UseTextStyle(TEXT_STYLE_PARSER);
			print (string) TEXT_STYLE_PARSER_PREFIX;
			print (string) txt;
			print (string) TEXT_STYLE_PARSER_SUFIX;
			UseTextStyle(previous_style);
		}
		temp = 0;
		switch (PressAnyKey()) {
			32, -6: done = true; ! Código de INTRO/ESPACIO
			'1': temp = 1;
			'2': temp = 2;
			'3': temp = 3;
		}
		if (temp > 0) {
			switch (DM.get_highlight_style(temp)) {
				TEXT_STYLE_UPRIGHT:
					highlight = TEXT_STYLE_STRESSED;
				TEXT_STYLE_STRESSED:
					highlight = TEXT_STYLE_NOTE;
				TEXT_STYLE_NOTE:
					highlight = TEXT_STYLE_IMPORTANT;
				TEXT_STYLE_IMPORTANT:
					highlight = TEXT_STYLE_HEADER;
				TEXT_STYLE_HEADER:
					highlight = TEXT_STYLE_MONOSPACED;
				TEXT_STYLE_MONOSPACED:
					highlight = TEXT_STYLE_REVERSED;
				TEXT_STYLE_REVERSED:
					highlight = TEXT_STYLE_USER1;
				TEXT_STYLE_USER1:
					highlight = TEXT_STYLE_UPRIGHT;
				default:
					highlight = -1;
			}
			DM.set_highlight_style(temp, highlight);
		}
	}
	EraseWindow();
	return true;
];

!!------------------------------------------------------------------------------
!! Pinta la imagen pasada como parámetro en la ventana gráfica 'graphicWindow'
!! (sólo en Glulx).
!!
!!	@param {Picture} img - Imagen Blorb que se pintará en la ventana
!!		gráfica 'graphicWindow'
!!	@returns {boolean} Verdadero
!!	@version 1.0
!!------------------------------------------------------------------------------
[ DrawSceneImage img;
	#Ifdef TARGET_GLULX;
	#Ifdef USE_GWINDOWS;
	graphicWindowLeft.setImage(img);
	graphicWindowRight.setImage(img);
	#Endif; ! USE_GWINDOWS;
	#Endif; ! TARGET_GLULX;
	img++; ! (por evitar alertas del compilador)
	return true;
];

!!------------------------------------------------------------------------------
!! Deja la ventana en blanco.
!!
!!	@returns {boolean} Verdadero
!!	@version 1.0
!!------------------------------------------------------------------------------
[ EraseWindow;
    #Ifdef TARGET_ZCODE;
    @erase_window -1;
    #Ifnot; ! TARGET_GLULX
    if (gg_quotewin) {
		glk($0024, gg_quotewin, 0); ! close_window
		gg_quotewin = 0;
    }
    glk($002A, gg_mainwin); ! window_clear
    if (gg_statuswin) glk($002A, gg_statuswin); ! window_clear
    #Endif;
	return true;
];

!!------------------------------------------------------------------------------
!! Realiza un efecto de subida de volumen gradual en tiempo real (sin detener
!! la aplicación) de un recurso de audio. En caso de que el recurso no se
!! encontrase en reproducción, se inicia antes con un volumen del 0%. Si no se
!! especifica el tiempo del efecto, la subida de volumen es inmediata. (Sólo en
!! GLULX.)
!!
!! Debe tenerse en cuenta que no pueden efectuarse dos efectos de Fade al mismo
!! tiempo. Si ya hay uno en ejecución, el nuevo no se lanza.
!!
!!	@param {Sound} track - El recurso de audio sobre el que se lanza el efecto.
!!		Si el recurso no estaba en reproducción primero la inicia con un
!!		volumen del 0%
!!	@param {integer} [volume=-1] - Volumen final en tanto por ciento con el
!!		que se reproduce la pista de audio. -1 para indicar el volumen global
!!		de la aplicación. Si el volumen actual es mayor que 'volume', retorna
!!		sin hacer nada
!!	@param {integer} [fade_time=0] - Milisegundos que dura el efecto de
!!		'fade in' desde un volumen del 0% al especificado por 'volume'
!!	@returns {boolean} Falso si el volumen pasado como parámetro es inferior al
!!		volumen actual del sonido. Verdadero en caso contrario
!!	@version 2.0
!!------------------------------------------------------------------------------
[ FadeInTrack track volume fade_time;
	#Ifdef TARGET_GLULX;
	#Ifdef USE_DAMUSIX;
	if (volume == 0) volume = -1;
	if (fade_time == 0 || Damusix.EnFade()) {
		Damusix.Volumen(track, volume);
		if (~~Damusix.SonandoDeFondo(track)) Damusix.Tocar(track);
	} else {
		if (~~Damusix.SonandoDeFondo(track)) {
			Damusix.Volumen(track, 0);
			Damusix.Tocar(track);
		}
		Damusix.FadeIn(track, fade_time, volume);
	}
	#Endif; ! USE_DAMUSIX;
	#Endif; ! TARGET_GLULX;
	return true;
];

!!------------------------------------------------------------------------------
!! Realiza un efecto de bajada gradual de volumen de un recurso de audio pasado
!! como parámetro. Permite especificar, además, si el efecto de bajada gradual
!! de volumen se realiza en tiempo real ---por defecto--- o deteniendo la
!! aplicación mientras se produce, y si debe reproducirse un nuevo recurso de
!! audio una vez finalizado el efecto.
!!
!! Debe tenerse en cuenta que no pueden efectuarse dos efectos de Fade al mismo
!! tiempo. Si ya hay uno en ejecución, el nuevo no se lanza.
!!
!!	@param {Sound} track - El recurso de audio sobre el que se lanza el efecto
!!	@param {integer} [volume=0] - Volumen final en tanto por ciento con el que
!!		finaliza el efecto. Si el volumen final es 0, la reproducción se
!!		detiene automáticamente
!!	@param {integer} [fade_time=0] - Milisegundos que dura el efecto de
!!		'fade out' desde el volumen actual al especificado por 'volume'. Si es
!!		0 ---por defecto---, la bajada de volumen es inmediata
!!	@param {boolean} [simple_fade_out=false] - Por defecto el efecto se realiza
!!		en tiempo real, pero si se invoca con este parámetro activado
!!		(==verdadero), la aplicación se detiene mientras se lleva a cabo el
!!		'fade out'
!!	@param {Sound} [post_track=0] - Recurso de audio a reproducir tras lanzar
!!		el efecto de 'fade out' sobre 'track'
!!	@returns {boolean} Verdadero
!!	@version 3.0
!!------------------------------------------------------------------------------
[ FadeOutTrack track volume fade_time simple_fade_out post_track;
	#Ifdef TARGET_GLULX;
	#Ifdef USE_DAMUSIX;
	if (Damusix.QueVolumen(track) == 0) return false;
	if (fade_time == 0 || Damusix.EnFade()) {
		if (volume == 0) Damusix.Parar(track);
		else Damusix.Volumen(track, volume);
		if (post_track) Damusix.Tocar(post_track);
	} else {
		if (simple_fade_out) {
			Damusix.SimpleFadeOut(track, fade_time, volume);
			if (post_track) Damusix.Tocar(post_track);
		} else {
			Damusix.FadeOut(track, fade_time, volume, post_track);
		}
	}
	#Endif; ! USE_DAMUSIX;
	#Endif; ! TARGET_GLULX;
	return true;
];

!!------------------------------------------------------------------------------
!! Imprime una regla horizontal centrada en pantalla.
!!
!!	@returns {boolean} Verdadero
!!	@version 2.0
!!------------------------------------------------------------------------------
[ HorizontalRule;
	return PrintCentered("*  *  *");
];

!!------------------------------------------------------------------------------
!! Selecciona el estilo de texto utilizado por la rutina para crear
!! hipervínculos. La rutina 'Hyperlink()' para crear hipervínculos la invoca en
!! dos ocasiones; antes y después de imprimir el texto del hipervínculo. El
!! resultado de la primera llamada se utiliza como primer parámetro de la
!! segunda (para que el estilo de texto tras imprimir el hipervínculo sea el
!! mismo que había antes).
!!
!!	@param {integer} style - Código numérico para identificar el estilo de
!!		texto a utilizar (utiliza los mismos códigos de los estilos de texto de
!!		la extensión 'textStyles')
!!	@param {Object|String} [item] - Objeto o cadena de caracteres sobre el que
!!		se genera el hipervínculo. Si se trata de un objeto, el estilo se
!!		selecciona automáticamente (con indiferencia del valor de 'style') en
!!		función de sus características
!!	@returns {integer} Código numérico del estilo utilizado con anterioridad
!!	@version 1.3
!!------------------------------------------------------------------------------
#Ifdef USE_HYPERLINKS;
[ HyperlinkSetStyle item style
	result;
	if (metaclass(item) == Object) {
		!! Objetos importantes en la obra:
		if (item has remarkable) {
			result = UseTextStyle(DM.get_highlight_style(1));
		}
		!! Objetos hacia los que el PC puede desplazarse:
		else if ((item ofclass AdjacentRoom or CompassDirection)
			|| (item has door)) {
			result = UseTextStyle(DM.get_highlight_style(2));
		!! Otros objetos:
		} else {
			result = UseTextStyle(DM.get_highlight_style(3));
		}
	} else {
		if (style < 0) style = style * -1;
		result = UseTextStyle(style);
	}

	return result;
];
#Endif; ! USE_HYPERLINKS;

!!------------------------------------------------------------------------------
!! Determina si el próximo hipervínculo que se va a crear en la extensión
!! 'hyperlinks' está o no activado.
!!
!!	@param {Object|String} item - Contiene al objeto o la cadena de caracteres
!!		sobre la que se va a generar el hipervínculo
!!	@param {integer} [code=0] - Si 'item' es una cadena de caracteres, se puede
!!		invocar la rutina con este parámetro negativo para forzar la
!!		desactivación del hipervínculo
!!	@returns {boolean} Verdadero para indicar que el hipervínculo está
!!		activado. Falso en caso contrario
!!	@version 1.1
!!------------------------------------------------------------------------------
#Ifdef USE_HYPERLINKS;
[ HyperlinkStatus item cancel
	result;
	result = true;
	if (metaclass(item) == Object) {
		!! Objetos importantes en la obra:
		if (item has remarkable) {
			result = DM.get_hyperlinks_status(1);
		}
		!! Objetos hacia los que el PC puede desplazarse:
		else if ((item ofclass Room or CompassDirection) || (item has door)) {
			result = DM.get_hyperlinks_status(2);
		!! Otros objetos:
		} else {
			result = DM.get_hyperlinks_status(3);
		}
	} else {
		if (cancel) result = false;
	}

	return result;
];
#Endif; ! USE_HYPERLINKS;

!!------------------------------------------------------------------------------
!! Indica si un recurso de audio está actualmente en reproducción (en términos
!! de la librería Damusix; si está sonando de fondo -- en reproducción con
!! repeticiones infinitas).
!!
!!	@param {Sound} track - El recurso de audio del que se desea saber si se
!!		está reproduciendo o no
!!	@returns {boolean} Verdadero si el recurso de audio 'track' se está
!!		reproduciendo. Falso en caso contrario
!!	@version 1.0
!!------------------------------------------------------------------------------
[ IsTrackPlaying track;
	#Ifdef TARGET_GLULX;
	#Ifdef USE_DAMUSIX;
	return Damusix.SonandoDeFondo(track);
	#Endif; ! USE_DAMUSIX;
	#Endif; ! TARGET_GLULX;
];

!!------------------------------------------------------------------------------
!! Menú principal de la aplicación. Permite al usuario lanzar funciones de
!! configuración, ver los créditos, cargar una partida guardada o salir de la
!! aplicación, además de iniciar el relato. Si la aplicación se encuentra en
!! modo depuración, permite seleccionar numéricamente la localidad inicial.
!!
!!	@retuns {Object} Localidad inicial del relato
!!	@version 1.0
!!------------------------------------------------------------------------------
[ MainMenu
	result done width previous_style i j line op length;
	!! Establece la imagen del menú:
	DrawSceneImage(PIC_INFIERNO_A);
	while (done == false) {
		EraseWindow();
		width = ScreenWidth() - 1;
		previous_style = DM.set_text_style(TEXT_STYLE_MONOSPACED);

		new_line;
		PrintCentered("L A   Z O N A");

		new_line;
		PrintCentered("*");

		new_line;
		PrintCentered("Por J. Francisco Martín");

		new_line;
		new_line;
		for (i = 1 : i <= 4 : i++) {
			switch (i) {
				1:
					line = "Empezar la historia";
					op = "[ESPACIO]";
					length = 32;
				2:
					line = "Configuración";
					op = "X";
					length = 18;
				3:
					line = "Recuperar partida guardada";
					op = "R";
					length = 31;
				4:
					line = "Salir de la aplicación";
					op = "Q";
					length = 27;
			}
			print (string) line;
			if (width > 33) {
				print "  ";
				for (j = 0 : j < (width - length) + 2 : j++) print ".";
				print "  ";
			} else {
				print ":^";
				print " ";
				if (i == 1) length = 4;
				else length = 8;
				for (j = 0 : j < length : j++) print ".";
				print " ";
			}
			print (string) op;
			new_line;
		}
		new_line;
		print "v";
		PrintVersionNumber();
		print "/";
		PrintSerialNumber();
		DM.set_text_style(previous_style);
		!! Reacción a la acción del usuario:
		switch (PressAnyKey()) {
			32, -6:	! Empezar la historia
				done = true;
				result = DM.get_initial_location();
			#Ifdef DEBUG;
			'1':
				done = true;
				result = Tunel;
			'2':
				done = true;
				result = Canal;
			'3':
				done = true;
				result = Callejon;
			'4':
				done = true;
				result = Azotea;
			'5':
				done = true;
				result = CalleEste;
			!! '6':
			!! 	done = true;
			!! 	result = CalleCentro;
			'7':
				done = true;
				result = CalleOeste;
			#Endif; ! DEBUG;
			'X', 'x': ! Configuración
				ConfigureHyperlinks("Pulsa @<<INTRO@>> para aceptar.");
				ConfigureHighlightStyle("Pulsa @<<INTRO@>> para aceptar.");
				DM.write_configuration_file(CONFIG_FILE_NAME);
			'R', 'r':	! Recuperar partida guardada
				new_line;
				EraseWindow();
				new_line;
				print (parser) "Cargando partida...";
				new_line;
				<Restore>;
				PressAnyKey();
			'Q', 'q':	! Salir de la aplicación
				new_line;
				EraseWindow();
				new_line;
				print (parser) "Pulsa una tecla para salir.";
				new_line;
				quit;
		}
	}
	!! Limpia la pantalla y retorna:
	EraseWindow();
	return result;
];

!!------------------------------------------------------------------------------
!! Rutina para esperar una pulsación de tecla del usuario antes de continuar.
!! Si se invoca con el primer parámetro opcional activado (verdadero), la
!! ejecución continúa sin ningún tipo de espera. Si se utiliza el segundo
!! parámetro opcional, la rutina espera a que pase esa cantidad de décimas de
!! segundo antes de continuar con la ejecución normal.
!!
!!	@param {boolean} [cancel=false] - Si es verdadero la rutina no espera a la
!!		pulsación de tecla del usuario y la aplicación puede continuar la
!!		ejecución normalmente
!!	@param {integer} [delay=0] - Si se introduce un entero, espera a que se
!!		cumpla la cantidad 'delay' de décimas de segundo antes de continuar.
!!		En caso contrario, espera a una pulsación de tecla del usuario
!!	@returns {char} Caracter introducido por el usuario
!!	@version 1.2
!!------------------------------------------------------------------------------
[ PressAnyKey cancel delay
	result;
	#Ifdef TARGET_GLULX;
	#Ifdef USE_DAMUSIX;
	if (Damusix.EnFade()) delay = 0;
	#Endif; ! USE_DAMUSIX;
	#Endif; ! TARGET_GLULX;
	if (delay > 0) result = KeyDelay(delay);
	else if (~~cancel) result = KeyCharPrimitive();
	return result;
];

!!------------------------------------------------------------------------------
!! Imprime la cadena de caracteres pasada como parámetro centrada en pantalla,
!! con estilo monoespaciado y seguido de una nueva línea.
!!
!!	@param {String} txt - Cadena de caracteres que se desea imprimir centrada.
!!		No puede tener una longitud superior a INPUT_BUFFER_LEN
!!	@returns {boolean} Verdadero
!!	@version 1.0
!!------------------------------------------------------------------------------
[ PrintCentered txt
	previous_style length;
	PrintToBuffer(temp_array, INPUT_BUFFER_LEN, txt);
	length = temp_array->(WORDSIZE-1);
	previous_style = DM.set_text_style(TEXT_STYLE_MONOSPACED);
	spaces (ScreenWidth()-1-length) / 2;
	PrintCharacterArray(temp_array);
	DM.set_text_style(previous_style);
	new_line;
	return true;
];

!!------------------------------------------------------------------------------
!! Rutina para imprimir el nombre corto de un objeto. Si se incluye la
!! extensión 'hyperlinks.h' se crea un hipervínculo relacionado con el objeto.
!!
!!	@returns {boolean} Verdadero
!!	@override parserm.h
!!	@version 1.1
!!------------------------------------------------------------------------------
[ PSN__ obj;
    if (obj == 0) { print (string) NOTHING__TX; rtrue; }
    switch (metaclass(obj)) {
      Routine:  print "<routine ", obj, ">"; rtrue;
      String:   print "<string ~", (string) obj, "~>"; rtrue;
      nothing:  print "<illegal object number ", obj, ">"; rtrue;
    }
    if (obj == player) { print (string) YOURSELF__TX; rtrue; }
    #Ifdef LanguagePrintShortName;
    if (LanguagePrintShortName(obj)) rtrue;
    #Endif; ! LanguagePrintShortName
    if (indef_mode && obj.&short_name_indef ~= 0
		&& PrintOrRun(obj, short_name_indef, 1) ~= 0)
		rtrue;
    if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, 1) ~= 0)
		rtrue;
	#Ifdef USE_HYPERLINKS;
	Hyperlink(obj);
	#Ifnot;
    print (object) obj;
	#Endif; ! USE_HYPERLINKS;
];

!!------------------------------------------------------------------------------
!! Imprime el pronombre nominativo correcto correspondiente a un objeto.
!!
!!	@param {Object} obj - Objeto del que se desea imprimir su pronombre
!!		nominativo
!!	@version 1.0
!!------------------------------------------------------------------------------
[ SpanishNominativePronoun obj;
	switch (GetGNAOfObject(obj)) {
		0, 6:	print "él";
		1, 7:	print "ella";
		2, 8:	print "ello";
		3, 9:	print "ellos";
		4, 10:	print "ellas";
		5, 11:	print "ellos";
	}
];

!!------------------------------------------------------------------------------
!! Imprime el pronombre nominativo correcto correspondiente a un objeto.
!!
!!	@param {Object} obj - Objeto del que se desea imprimir su pronombre
!!		nominativo
!!	@version 1.0
!!------------------------------------------------------------------------------
[ SpanishNominativePronounCap obj;
	switch (GetGNAOfObject(obj)) {
		0, 6:	print "Él";
		1, 7:	print "Ella";
		2, 8:	print "Ello";
		3, 9:	print "Ellos";
		4, 10:	print "Ellas";
		5, 11:	print "Ellos";
	}
];


!!==============================================================================
!!
!!	8)	Gramática estándar y extendida
!!
!!------------------------------------------------------------------------------
!!	IMPORTANTE: Los mensajes de algunas de las acciones que se añaden requieren
!!	la extensión 'SpanishLM.h'. Acciones añadidas o modificadas:
!!	<>	##Audio / ##AudioOn / ##AudioOff
!!	<>	##Configuration
!!	<>	##DefaultAction
!!	<>	##Enter
!!	<>	##Exits
!!	<>	##GoBack / ##GoForward
!!	<>	##LMode2
!!	<>	##NoSuchVerb --- Permite eliminar las acciones:
!!		-	##Sorry
!!	<>	##ShootAt
!!	<>	##TalkOn / ##TalkTo
!!	<>	##TestCustom
!!	<>	##TestGroup2
!!	<>	##TestGroup3
!!------------------------------------------------------------------------------

Include "SpanishG.h";			! Gramática española
Include "SpanishEG.h";			! Gramática española extendida

!!------------------------------------------------------------------------------
!! ##Audio / ##AudioOn / ##AudioOff
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef USE_DAMUSIX;
Verb meta 'audio' 'music' 'musica' 'sonido' 'sonidos'
	*								-> Audio
	* 'on' / 'si'					-> AudioOn
	* 'encendido' / 'activado'		-> AudioOn
	* 'off' / 'no'					-> AudioOff
	* 'apagado' / 'desactivado'		-> AudioOff
;
VerboIrregular "establecer la reproducción de audio" with imperativo
	'audio' 'music' 'musica' 'sonido' 'sonidos';

[ AudioSub;
	if (Damusix.HayAudio()) <<AudioOff>>;
	else <<AudioOn>>;
];

[ AudioOnSub;
	if (Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba activada.";
	Damusix.ActivarAudio();
	print_ret (parser) "Reproducción de audio activada.";
];

[ AudioOffSub;
	if (~~Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba desactivada.";
	Damusix.DesactivarAudio();
	print_ret (parser) "Reproducción de audio desactivada.";
];
#Endif; ! USE_DAMUSIX;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##Configuration
!!------------------------------------------------------------------------------

Verb meta 'config' 'configuracion' 'enlace' 'enlaces' 'hiperenlace'
	'hiperenlaces' 'hipervinculo' 'hipervinculos' 'resaltado' 'vinculo'
	'vinculos'
	*								-> Configuration
;

VerboIrregular "establecer opciones de configuración" with imperativo
	'config' 'configuracion' 'enlace' 'enlaces' 'hiperenlace' 'hiperenlaces'
	'hipervinculo' 'hipervinculos' 'resaltado' 'vinculo' 'vinculos';

[ ConfigurationSub;
	ConfigureHyperlinks("Pulsa @<<INTRO@>> para aceptar.");
	ConfigureHighlightStyle("Pulsa @<<INTRO@>> para aceptar.");
	DM.write_configuration_file(CONFIG_FILE_NAME);
	<<Look>>;
];

!!------------------------------------------------------------------------------
!! ##DefaultAction
!!------------------------------------------------------------------------------
!!	Los objetos pueden definir una propiedad: 'action_set', con un array de
!!	acciones evidentes que pueden realizarse sobre ese objeto. Si definen esta
!!	propiedad, la acción por defecto imprime el listado de acciones. En caso
!!	contrario, la acción por defecto se limita a invocar la acción ##Examine
!!	sobre ese objeto.
!!------------------------------------------------------------------------------

Verb 'no.verb'
	* noun							-> DefaultAction
;

[ DefaultActionSub;
	!! Por evitar redundancias, cuando la instrucción por defecto lanza
	!! ##Examine no se muestra aclaración de la entrada y se hace únicamente en
	!! los demás casos:
	!! previous_style = DM.set_text_style(TEXT_STYLE_PARSER);
	!! print (string) TEXT_STYLE_PARSER_PREFIX;
	!! print "examina ", (name) noun;
	!! print (string) TEXT_STYLE_PARSER_SUFIX;
	!! DM.set_text_style(previous_style);
	!! new_line;
	<<Examine noun>>;
];

!!------------------------------------------------------------------------------
!! ##Enter
!!------------------------------------------------------------------------------

[ AnAdjacentRoom;
	if (noun ofclass AdjacentRoom) return true;
	else return false;
];

Extend only 'anda' 'camina' 'corre' 'ir' 've' 'vete' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;

Extend only 'baja' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;

Extend only 'bajarse' 'bajarte' 'bajate' 'sal' 'salirse' 'salirte' 'salte' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;

Verb 'bajame' = 'bajate';
Verb 'bajale' = 'bajate';

Extend only 'entra' 'cruza' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;

Extend only 'meteme' 'meterme' 'meterse' 'meterte' 'metete' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;

Extend only 'pasa' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;

Extend only 'sube' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;
Extend only 'subete' 'subirse' 'subirte' last
	* noun=AnAdjacentRoom							-> Enter
	* 'a//'/'en' noun=AnAdjacentRoom				-> Enter
	* 'hacia'/'por' noun=AnAdjacentRoom				-> Enter
	* 'hasta' noun=AnAdjacentRoom					-> Enter
;

Verb 'subele' = 'sube';
Verb 'subeme' = 'sube';
Verb 'subirle' = 'sube';
Verb 'subirme' = 'sube';

!!------------------------------------------------------------------------------
!! ##Exits
!!------------------------------------------------------------------------------

Verb meta 'dirs' 'direcciones' 'salidas'
	*								-> Exits
;
VerboIrregular "listar salidas" with imperativo
	'dirs' 'direcciones' 'salidas';

[ ExitsSub;
	noun = real_location;
	if (~~real_location.before()) {
		print_ret (parser) "No se observan salidas obvias desde la localidad
		actual.";
	}
];

!!------------------------------------------------------------------------------
!!	##GoBack / ##GoForward
!!------------------------------------------------------------------------------

!! FIXME
!! Verb 'retrocede'
!!  	*								-> GoBack
!!  	* noun							-> Enter
!!  	* 'por' noun					-> Enter
!! ;

Verb 'avanza' 'continua' 'sigue'
	*								-> GoForward
	* noun							-> Enter
	* 'por' noun					-> Enter
; VerboIrregular "seguir" with imperativo 'sigue';

!! FIXME
!! [ GoBackSub;
!! 	<<Go b_obj>>;
!! ];

[ GoForwardSub;
	<<Go f_obj>>;
];

!!------------------------------------------------------------------------------
!! ##LMode2
!!------------------------------------------------------------------------------

Extend only 'normal' replace
    *								-> LMode2
;

!!------------------------------------------------------------------------------
!! ##NoSuchVerb
!!------------------------------------------------------------------------------
!! Permite eliminar acciones definidas automáticamente por la librería Inform.
!! Código extraído de <http://www.firthworks.com/roger/informfaq/vv.html#6>.
!!------------------------------------------------------------------------------

[ Anything; ! Se ignora el resto de la entrada de usuario
	while (NextWordStopped() ~= -1);
	return GPR_PREPOSITION;
];

Extend	'nx' replace
	* Anything						-> NoSuchVerb
;

Extend	'perdona' replace
	* Anything						-> NoSuchVerb
;

[ NoSuchVerbSub; return ParserError(VERB_PE); ];

!!------------------------------------------------------------------------------
!! ##ShootAt
!!------------------------------------------------------------------------------

Verb	'dispara'
	* noun							-> ShootAt
	* 'a' noun						-> ShootAt
;

[ ShootAtSub;
    if (noun == Fusil) {
        "", (parser) "Tienes que indicar a qué quieres disparar con el arma.";
    }
	switch (DM.get_grammatical_inflection()) {
		FIRST_PERSON_PRESENT,
		SECOND_PERSON_PRESENT,
		THIRD_PERSON_PRESENT:
			"No tiene ningún sentido disparar ", (al) noun, ".";
		FIRST_PERSON_PAST,
		SECOND_PERSON_PAST,
		THIRD_PERSON_PAST:
			"No tenía ningún sentido disparar ", (al) noun, ".";
		FIRST_PERSON_FUTURE,
		SECOND_PERSON_FUTURE,
		THIRD_PERSON_FUTURE:
			"No tendrá ningún sentido disparar ", (al) noun, ".";
	}
];

!!------------------------------------------------------------------------------
!! ##TalkOn / ##TalkTo
!!------------------------------------------------------------------------------

Extend	'habla' replace
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

Verb	'conversa' 'platica'
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

[ TalkOnSub
	previous_style;
	previous_style = DM.set_text_style(TEXT_STYLE_PARSER);
	print (string) TEXT_STYLE_PARSER_PREFIX;
	print "Hablar con ", (name) noun;
	print (string) TEXT_STYLE_PARSER_SUFIX;
	DM.set_text_style(previous_style);
	new_line;
	<<TalkTo noun second>>;
];

[ TalkToSub;
	!! 1) El personaje intenta hablar consigo mismo:
	if ( noun == player ) {
		print "Hablar con un", (o) player, " mism", (o) player, " ";
		switch (_grammatical_inflection) {
			FIRST_PERSON_PRESENT,
			SECOND_PERSON_PRESENT,
			THIRD_PERSON_PRESENT:
				"no resulta especialmente interesante.";
			FIRST_PERSON_PAST,
			SECOND_PERSON_PAST,
			THIRD_PERSON_PAST:
				"no resultaba especialmente interesante.";
			FIRST_PERSON_FUTURE,
			SECOND_PERSON_FUTURE,
			THIRD_PERSON_FUTURE:
				"no resultará especialmente interesante.";
		}
	}
	!! 2) El personaje intenta hablar con un objeto inanimado:
	if ( noun hasnt animate ) {
		switch (_grammatical_inflection) {
			FIRST_PERSON_PRESENT,
			SECOND_PERSON_PRESENT,
			THIRD_PERSON_PRESENT:
				"Sería más interesante intentar hablar con cosas que puedan
				devolver una respuesta.";
			FIRST_PERSON_PAST,
			SECOND_PERSON_PAST,
			THIRD_PERSON_PAST:
				"Hubiese sido más interesante intentar hablar con cosas que
				pudiesen devolver una respuesta.";
			FIRST_PERSON_FUTURE,
			SECOND_PERSON_FUTURE,
			THIRD_PERSON_FUTURE:
				"Será más interesante intentar hablar con cosas que puedan
				devolver una respuesta.";
		}
	}
	!! 3) El personaje intenta hablar con un objeto animado:
	switch (_grammatical_inflection) {
		FIRST_PERSON_PRESENT:
		SECOND_PERSON_PRESENT,
		THIRD_PERSON_PRESENT:
			print (The) noun, " no parecen", (n) noun;
		FIRST_PERSON_PAST,
		SECOND_PERSON_PAST,
		THIRD_PERSON_PAST:
			print (The) noun, " no parecía", (n) noun;
		FIRST_PERSON_FUTURE,
		SECOND_PERSON_FUTURE,
		THIRD_PERSON_FUTURE:
			print (The) noun, " no parecerá", (n) noun;
	}
	" interesad", (o) noun, " en hablar ", (contigo) player, ".";
];

!!------------------------------------------------------------------------------
!! ##TestCustom
!!------------------------------------------------------------------------------

#Ifdef DEBUG;
Verb meta	'testx'
	* noun							-> TestCustom
;

[ TestCustomSub;
	print "^##Dance ", (name) noun, ":^";
	<Dance noun>;
	!! ##GoDown
	!! ##GoUp
	print "^##KnockOn ", (name) noun, ":^";
	<KnockOn noun>;
	print "^##Masturbate ", (name) noun, ":^";
	<Masturbate noun>;
	if (player notin noun) {
		print "^##Sit ", (name) noun, ":^";
		<Sit noun>;
		print "^##StandUp ", (name) noun, ":^";
		<StandUp noun>;
	} else {
		print "^##StandUp ", (name) noun, ":^";
		<StandUp noun>;
		print "^##Sit ", (name) noun, ":^";
		<Sit noun>;
	}
	print "^##SleepWith ", (name) noun, ":^";
	<SleepWith noun>;
	print "^##TalkTo ", (name) noun, ":^";
	<TalkTo noun>;
	print "^##Untie ", (name) noun, ":^";
	<Untie noun>;
	print "^##Use ", (name) noun, ":^";
	<Use noun>;
	print "^##Write ", (name) noun, ":^";
	<Write noun>;
	print "^##Xyzzy ", (name) noun, ":^";
	<Xyzzy noun>;
];
#Endif; ! DEBUG;

!!------------------------------------------------------------------------------
!! ##TestGroup2
!!------------------------------------------------------------------------------

#Ifdef DEBUG;
Verb meta	'test2'
	* noun							-> TestGroup2
;

[ TestGroup2Sub;
	if (noun has open) {
		print "^##Close ", (name) noun, ":^";
		<Close noun>;
		print "^##Open ", (name) noun, ":^";
		<Open noun>;
	} else {
		print "^##Open ", (name) noun, ":^";
		<Open noun>;
		print "^##Close ", (name) noun, ":^";
		<Close noun>;
	}
	if (noun has worn) {
		print "^##Disrobe ", (name) noun, ":^";
		<Disrobe noun>;
		print "^##Wear ", (name) noun, ":^";
		<Wear noun>;
	} else {
		print "^##Wear ", (name) noun, ":^";
		<Wear noun>;
		print "^##Disrobe ", (name) noun, ":^";
		<Disrobe noun>;
	}
	if (IndirectlyContains(player, noun)) {
		print "^##Drop ", (name) noun, ":^";
		<Drop noun>;
		print "^##Take ", (name) noun, ":^";
		<Take noun>;
	} else {
		print "^##Take ", (name) noun, ":^";
		<Take noun>;
		print "^##Drop ", (name) noun, ":^";
		<Drop noun>;
	}
	print "^##Eat ", (name) noun, ":^";
	<Eat noun>;
	print "^##Empty ", (name) noun, ":^";
	<Empty noun>;
	!! ##EmptyT
	if (noun hasnt door) {
		print "^##Enter ", (name) noun, ":^";
		<Enter noun>;
		print "^##Exit ", (name) noun, ":^";
		<Exit noun>;
		print "^##GoIn ", (name) noun, ":^";
		<GoIn noun>;
		print "^##GetOff ", (name) noun, ":^";
		<GetOff noun>;
	}
	print "^##Examine ", (name) noun, ":^";
	<Examine noun>;
	if (noun has locked) {
		print "^##Unlock ", (name) noun, ":^";
		<Unlock noun>;
		print "^##Lock ", (name) noun, ":^";
		<Lock noun>;
	} else {
		print "^##Lock ", (name) noun, ":^";
		<Lock noun>;
		print "^##Unlock ", (name) noun, ":^";
		<Unlock noun>;
	}
	!! ##Give
	!! ##Go
	!! ##Insert
	!! ##Inv
	!! ##InvTall
	!! ##InvWide
	!! ##Look
	!! ##Order
	!! ##PutOn
	print "^##Remove ", (name) noun, ":^";
	<Remove noun>;
	print "^##Search ", (name) noun, ":^";
	<Search noun>;
	print "^##Show ", (name) noun, ":^";
	<Show noun>;
	if (noun has on) {
		print "^##SwitchOff ", (name) noun, ":^";
		<SwitchOff noun>;
		print "^##SwitchOn ", (name) noun, ":^";
		<SwitchOn noun>;
	} else {
		print "^##SwitchOn ", (name) noun, ":^";
		<SwitchOn noun>;
		print "^##SwitchOff ", (name) noun, ":^";
		<SwitchOff noun>;
	}
	!! ##Transfer
	!! ##VagueGo
];
#Endif; ! DEBUG;

!!------------------------------------------------------------------------------
!! ##TestGroup3
!!------------------------------------------------------------------------------

#Ifdef DEBUG;
Verb meta	'test3'
	* noun							-> TestGroup3
;

[ TestGroup3Sub;
	!! ##Answer
	!! ##Ask
	!! ##AskFor
	print "^##Attack ", (name) noun, ":^";
	<Attack noun>;
	print "^##Blow ", (name) noun, ":^";
	<Blow noun>;
	print "^##Burn ", (name) noun, ":^";
	<Burn noun>;
	print "^##Buy ", (name) noun, ":^";
	<Buy noun>;
	print "^##Climb ", (name) noun, ":^";
	<Climb noun>;
	print "^##Consult ", (name) noun, ":^";
	<Consult noun>;
	print "^##Cut ", (name) noun, ":^";
	<Cut noun>;
	print "^##Dig ", (name) noun, ":^";
	<Dig noun>;
	print "^##Drink ", (name) noun, ":^";
	<Drink noun>;
	print "^##Fill ", (name) noun, ":^";
	<Fill noun>;
	!! ##Jump
	print "^##JumpOver ", (name) noun, ":^";
	<JumpOver noun>;
	print "^##Kiss ", (name) noun, ":^";
	<Kiss noun>;
	!! ##LetGo
	print "^##Listen ", (name) noun, ":^";
	<Listen noun>;
	print "^##LookUnder ", (name) noun, ":^";
	<LookUnder noun>;
	print "^##Mild ", (name) noun, ":^";
	<Mild noun>;
	!! ##No
	print "^##Pray ", (name) noun, ":^";
	<Pray noun>;
	print "^##Pull ", (name) noun, ":^";
	<Pull noun>;
	print "^##Push ", (name) noun, ":^";
	<Push noun>;
	print "^##PushDir ", (name) noun, ":^";
	<PushDir noun>;
	!! ##Receive
	print "^##Rub ", (name) noun, ":^";
	<Rub noun>;
	print "^##Set ", (name) noun, ":^";
	<Set noun>;
	print "^##SetTo ", (name) noun, ":^";
	<SetTo noun>;
	print "^##Sing ", (name) noun, ":^";
	<Sing noun>;
	print "^##Sleep ", (name) noun, ":^";
	<Sleep noun>;
	print "^##Smell ", (name) noun, ":^";
	<Smell noun>;
	print "^##Sorry ", (name) noun, ":^";
	<Sorry noun>;
	print "^##Squeeze ", (name) noun, ":^";
	<Squeeze noun>;
	print "^##Strong ", (name) noun, ":^";
	<Strong noun>;
	print "^##Swim ", (name) noun, ":^";
	<Swim noun>;
	print "^##Swing ", (name) noun, ":^";
	<Swing noun>;
	print "^##Taste ", (name) noun, ":^";
	<Taste noun>;
	print "^##Tell ", (name) noun, ":^";
	<Tell noun>;
	print "^##Think ", (name) noun, ":^";
	<Think noun>;
	print "^##ThrowAt ", (name) noun, ":^";
	<ThrowAt noun>;
	print "^##Tie ", (name) noun, ":^";
	<Tie noun>;
	print "^##Touch ", (name) noun, ":^";
	<Touch noun>;
	print "^##Turn ", (name) noun, ":^";
	<Turn noun>;
	print "^##Wait ", (name) noun, ":^";
	<Wait noun>;
	print "^##Wake ", (name) noun, ":^";
	<Wake noun>;
	print "^##WakeOther ", (name) noun, ":^";
	<WakeOther noun>;
	print "^##Wave ", (name) noun, ":^";
	<Wave noun>;
	print "^##WaveHands ", (name) noun, ":^";
	<WaveHands noun>;
	print "^##Yes ", (name) noun, ":^";
	<Yes noun>;
];
#Endif; ! DEBUG;


!!==============================================================================
!!
!!	9)	Definición de atributos, clases y objetos
!!
!!------------------------------------------------------------------------------

Include ">laZona_dm.inf";
Include ">laZona_classes.inf";
Include ">laZona_objects.inf";
